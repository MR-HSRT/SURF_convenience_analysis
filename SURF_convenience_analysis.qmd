---
title: "Deskriptive Auswertung Umfragedaten"
format:
  html:
    toc: true
    number-sections: true
    theme: cosmo
execute:
  echo: false
  warning: false
  message: false
  cache: false
---

```{r}
SURF_LOGO_PATH <- here::here("doc", "survey", "Logo-Surf-RGB.png")

```

::: {.text-center}
![](doc/survey/Logo-Surf-RGB.svg){fig-alt="SURF Projektlogo" width=280px}
:::

```{r}
#| label: setup
#| include: false

# ----------------------------
# 1) Pakete installieren, prüfen und laden
# ----------------------------

# Stabiler CRAN-Mirror (wichtig, falls RStudio alte Repos nutzt)
options(repos = c(CRAN = "https://cloud.r-project.org"))

required_pkgs <- c(
  "here","readr","dplyr","tidyr","stringr","janitor","labelled",
  "psych","gtsummary","flextable","ggplot2","scales","broom","knitr",
  "readxl", "webshot2"
)

# Fehlende Pakete ermitteln
missing_pkgs <- required_pkgs[!vapply(required_pkgs, requireNamespace, logical(1), quietly = TRUE)]

# Fehlende Pakete installieren (ohne Stop; mit klarer Meldung)
if (length(missing_pkgs) > 0) {
  message("Installiere fehlende Pakete: ", paste(missing_pkgs, collapse = ", "))
  tryCatch(
    {
      install.packages(missing_pkgs, dependencies = TRUE)
    },
    error = function(e) {
      message("Paketinstallation fehlgeschlagen: ", conditionMessage(e))
      message("Hinweis: Bitte R/RStudio neu starten und erneut ausführen. ",
              "Falls weiterhin Probleme: R als Admin starten oder Schreibrechte für die Library prüfen.")
    }
  )
}

# Pakete laden (leise; ohne Fehlermeldungsflut)
loaded <- vapply(required_pkgs, function(pkg) {
  suppressWarnings(suppressPackageStartupMessages(require(pkg, character.only = TRUE)))
}, logical(1))

# Wenn etwas trotz Install-Versuch nicht ladbar ist: nur eine kompakte Warnung
if (any(!loaded)) {
  warning("Folgende Pakete konnten nicht geladen werden: ",
          paste(required_pkgs[!loaded], collapse = ", "),
          call. = FALSE)
}

# ----------------------------
# 2) Ordnerstruktur erstellen
# ----------------------------
dir.create(here::here("data", "raw"),        recursive = TRUE, showWarnings = FALSE)
dir.create(here::here("data", "processed"),  recursive = TRUE, showWarnings = FALSE)
dir.create(here::here("outputs", "plots"),   recursive = TRUE, showWarnings = FALSE)
dir.create(here::here("outputs", "tables"),  recursive = TRUE, showWarnings = FALSE)

# ----------------------------
# 3) Reproduzierbarkeit
# ----------------------------
set.seed(1234)

PLOTS_DIR  <- here::here("outputs", "plots")
TABLES_DIR <- here::here("outputs", "tables")

# ----------------------------
# 4) .gitignore sicherstellen
# ----------------------------
# gitignore_path <- here::here(".gitignore")
# 
# gitignore_content <- c(
#   "# --- R / RStudio ---",
#   ".Rproj.user/",
#   ".Rhistory",
#   ".RData",
#   ".Ruserdata",
#   "",
#   "# --- Data files ---",
#   "*.csv",
#   "*.xlsx",
#   "*.json",
#   "",
#   "# --- Quarto ---",
#   "*_cache/",
#   "*_files/",
#   "",
#   "# --- Private data (NEVER commit) ---",
#   "data/raw/",
#   "data/processed/",
#   "",
#   "# --- Local secrets ---",
#   ".env"
# )
# 
# if (!file.exists(gitignore_path)) {
#   writeLines(gitignore_content, gitignore_path)
# } else {
#   existing_raw  <- readLines(gitignore_path, warn = FALSE)
#   existing_trim <- trimws(existing_raw)
# 
#   to_add <- gitignore_content[!gitignore_content %in% existing_trim]
# 
#   if (length(to_add) > 0) {
#     writeLines(c(existing_raw, to_add), gitignore_path)
#   }
# }

```

```{r}
#| label: import-data
#| include: false

# Pfad zur neuen LimeSurvey-Exceldatei
xlsx_path <- here::here("data", "raw", "results-survey739381.xlsx")

# Einlesen (Excel)
daten <- readxl::read_xlsx(xlsx_path)

# Spaltennamen bereinigen (snake_case)
daten <- janitor::clean_names(daten)

# QC Datensatz erstellen
surf_check <- daten

```

```{r}
#| label: surf-plot-style
#| include: false

# Pakete (minimal für Branding)
if (!requireNamespace("png", quietly = TRUE)) install.packages("png")
if (!requireNamespace("cowplot", quietly = TRUE)) install.packages("cowplot")

library(grid)
library(png)
library(cowplot)

# Pfad zum SURF-Logo
SURF_LOGO_PATH <- here::here("doc", "survey", "Logo-Surf-RGB.png")

# Corporate-Farben (aus dem bereitgestellten SURF-Logo abgeleitet)
SURF_PURPLE <- "#602890"
SURF_PINK   <- "#E81878"
SURF_MAG    <- "#902088"
SURF_TEXT   <- "#2B2B2B"
SURF_GRID   <- "#D9D9D9"

theme_surf <- function(base_size = 12, base_family = "") {
  ggplot2::theme_minimal(base_size = base_size, base_family = base_family) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title   = ggplot2::element_text(face = "bold", colour = SURF_TEXT, size = base_size * 1.15),
      plot.subtitle= ggplot2::element_text(colour = SURF_TEXT, size = base_size * 0.95),
      axis.title   = ggplot2::element_text(colour = SURF_TEXT),
      axis.text    = ggplot2::element_text(colour = SURF_TEXT),
      panel.grid.minor = ggplot2::element_blank(),
      panel.grid.major = ggplot2::element_line(colour = SURF_GRID, linewidth = 0.3),
      plot.margin = ggplot2::margin(12, 12, 12, 12)
    )
}

# Logo als Grob laden
surf_logo_grob <- function(path = SURF_LOGO_PATH) {
  if (!file.exists(path)) return(NULL)
  img <- png::readPNG(path)
  grid::rasterGrob(img, interpolate = TRUE)
}

# Plot + Logo (oben rechts, relative Koordinaten, robust)
brand_plot_surf <- function(p, logo_path = SURF_LOGO_PATH,
                            x = 0.98, y = 0.98, w = 0.16, h = 0.16) {
  lg <- surf_logo_grob(logo_path)
  if (is.null(lg)) return(p)

  cowplot::ggdraw(p) +
    cowplot::draw_grob(lg, x = x - w, y = y - h, width = w, height = h, hjust = 0, vjust = 0)
}

```

```{r}
#| label: surf-legend-style
#| include: false

# Standard-Legende: kompakt, mehrzeilig, passt in Exportplots
surf_legend_bottom <- function(nrow = 2, text_size = 9) {
  list(
    ggplot2::theme(
      legend.position = "bottom",
      legend.direction = "horizontal",
      legend.box = "horizontal",
      legend.text = ggplot2::element_text(size = text_size, colour = SURF_TEXT),
      legend.key.size = grid::unit(0.5, "lines"),
      legend.spacing.x = grid::unit(0.4, "lines")
    ),
    ggplot2::guides(
      fill = ggplot2::guide_legend(nrow = nrow, byrow = TRUE)
    )
  )
}

```

```{r}
#| label: surf-label-utils
#| include: false

# Prozent-Formatierung (einheitlich)
fmt_pct <- function(x, acc = 1) scales::percent(x, accuracy = acc)

# Label nur anzeigen, wenn Segment groß genug ist (gegen Overplotting)
pct_if_big <- function(x, min_pct = 0.05, acc = 0) {
  dplyr::if_else(x >= min_pct, fmt_pct(x, acc), "")
}

# Labels für horizontale Balken (Prozent rechts außen)
add_bar_labels_h <- function(size = 3.2, acc = 1, colour = SURF_TEXT) {
  ggplot2::geom_text(
    ggplot2::aes(label = fmt_pct(..x.., acc)),
    stat = "identity",
    hjust = -0.05,
    size = size,
    colour = colour
  )
}

# Labels für vertikale Balken (Prozent über Balken)
add_bar_labels_v <- function(size = 3.2, acc = 1, colour = SURF_TEXT, vjust = -0.4) {
  ggplot2::geom_text(
    ggplot2::aes(label = fmt_pct(y, acc)),
    vjust = vjust,
    size = size,
    colour = colour
  )
}

# Labels in 100%-Stacked Segmenten (nur wenn Segment >= min_pct)
add_stack_labels <- function(size = 3.0, acc = 0, min_pct = 0.06, colour = "white") {
  ggplot2::geom_text(
    ggplot2::aes(label = pct_if_big(Anteil_prop, min_pct = min_pct, acc = acc)),
    position = ggplot2::position_stack(vjust = 0.5),
    size = size,
    colour = colour
  )
}

# Labels für Punktplots (Mean über Punkt)
add_point_labels <- function(size = 3.1, digits = 2, colour = SURF_TEXT, vjust = -1) {
  ggplot2::geom_text(
    ggplot2::aes(label = round(mean, digits)),
    vjust = vjust,
    size = size,
    colour = colour
  )
}

# Labels für Prozentpunkte in Differenzplots (außerhalb, links/rechts je Vorzeichen)
add_diff_labels_h <- function(xvar = "diff", size = 3.2, acc = 1, colour = SURF_TEXT) {
  ggplot2::geom_text(
    ggplot2::aes(label = fmt_pct(.data[[xvar]], acc)),
    hjust = ifelse(control_diff[[xvar]] >= 0, -0.05, 1.05),
    size = size,
    colour = colour
  )
}

```

```{r}
#| label: custom-functions
#| include: false

# Save-Plot Engine
save_plot <- function(plot, block, sub, slug,
                      width = 8, height = 5, dpi = 300) {
  filename <- sprintf("%02d_%02d_%s.png", block, sub, slug)
  path <- file.path(PLOTS_DIR, filename)
  ggplot2::ggsave(filename = path, plot = plot, width = width, height = height, dpi = dpi)
  invisible(path)
}

# Mean + SD + SE + 95%-CI + n
mean_ci_n <- function(x) {
  x <- x[!is.na(x)]
  n <- length(x)

  # Falls n < 2: CI nicht sinnvoll -> NA
  m <- mean(x)
  s <- if (n >= 2) stats::sd(x) else NA_real_
  se <- if (!is.na(s)) s / sqrt(n) else NA_real_
  ci <- if (!is.na(se) && n >= 2) stats::qt(0.975, df = n - 1) * se else NA_real_

  tibble::tibble(
    n = n,
    mean = m,
    sd = s,
    se = se,
    ymin = if (!is.na(ci)) m - ci else NA_real_,
    ymax = if (!is.na(ci)) m + ci else NA_real_
  )
}

# ---- Flextable Theme (SURF Look) ----
theme_ft_surf <- function(ft,
                          font_size = 10,
                          header_bg = "#F5F5F5",
                          line_col = "#D9D9D9",
                          line_w_header = 1,
                          line_w_body = 0.7,
                          padding = 4) {

  if (!requireNamespace("officer", quietly = TRUE)) install.packages("officer")

  ft |>
    flextable::autofit() |>
    flextable::fontsize(size = font_size, part = "all") |>
    flextable::padding(padding = padding, part = "all") |>
    flextable::bold(part = "header") |>
    flextable::bg(bg = header_bg, part = "header") |>
    flextable::border_remove() |>
    flextable::hline_top(
      border = officer::fp_border(color = line_col, width = line_w_header),
      part = "all"
    ) |>
    flextable::hline_bottom(
      border = officer::fp_border(color = line_col, width = line_w_header),
      part = "all"
    ) |>
    flextable::hline(
      border = officer::fp_border(color = line_col, width = line_w_body),
      part = "body"
    )
}

# ---- Convenience: make SURF flextable from data ----
make_ft_surf <- function(data,
                         caption = NULL,
                         align_left_cols = NULL,
                         align_right_cols = NULL,
                         font_size = 10) {

  ft <- flextable::flextable(data)

  if (!is.null(align_left_cols)) {
    ft <- flextable::align(ft, j = align_left_cols, align = "left", part = "all")
  }
  if (!is.null(align_right_cols)) {
    ft <- flextable::align(ft, j = align_right_cols, align = "right", part = "all")
  }

  ft <- theme_ft_surf(ft, font_size = font_size)

  if (!is.null(caption)) {
    ft <- flextable::set_caption(ft, caption = caption)
  }

  ft
}

# ---- PNG Export (tight, PPT-friendly) ----
export_flextable_png <- function(ft,
                                 filename_base,
                                 tables_dir = TABLES_DIR,
                                 res = 300,
                                 overwrite = TRUE) {

  # flextable image export needs either "magick" or "ragg" (depending on setup).
  # We try to install what is needed.
  if (!requireNamespace("flextable", quietly = TRUE)) install.packages("flextable")
  if (!requireNamespace("magick", quietly = TRUE)) {
    # magick is best for tight cropping; if install fails, save_as_image may still work via other devices
    try(install.packages("magick"), silent = TRUE)
  }

  dir.create(tables_dir, recursive = TRUE, showWarnings = FALSE)

  png_file <- file.path(tables_dir, paste0(filename_base, ".png"))

  if (!overwrite && file.exists(png_file)) {
    stop("Export abgebrochen, da overwrite = FALSE und Datei bereits existiert: ", png_file)
  }

  # This usually creates a tightly-cropped image of the table
  flextable::save_as_image(
    x = ft,
    path = png_file,
    res = res
  )

  invisible(png_file)
}


force_rand_freq_order <- function(x) {
  x <- as.character(x)
  x <- stringr::str_trim(x)
  x <- stringr::str_replace_all(x, "–", "-")      # En-Dash -> Minus
  x <- stringr::str_replace_all(x, "\\s+", "")    # alle Leerzeichen raus (z.B. "3 - 5" -> "3-5")

  factor(x, levels = c("3-5", "10-15", "20-30"))
}

```

# Datenreport: SURF Convenience Survey

Vom XXX bis zum 28.02.2026 wird das SURF Convenience-Survey von den SURF Projektpartnern digital über unterschiedliche Kanäle gestreut.
Zu diesem Zweck wurde die Online-Umfrage über interne und externe Newsletter, Social Media Plattformen, und Online-Foren gestreut.
Ziel dieser ersten Umfrage ist es, eine erste Erhebung der Akzeptanz von und Präferenzen für die digitale SURF-Plattform zu erheben,
und einen umfangreichen Test der Umfrage durchzuführen. Die so erhobenen Ergebnisse fliessen in die Weiterentwicklung der Umfrage und andere Projektbestandteile, sowie in die praktische Entwicklungsarbeit der Umfrage ein.

## Aufbau und Inhalte der Umfrage

Die SURF-Umfrage erfasst Einstellungen, Präferenzen und Zahlungsbereitschaften von Haushalten in Bezug auf eine digitale Plattform zur netzdienlichen Steuerung steuerbarer Haushaltsgeräte. Der Fragebogen kombiniert allgemeine Einstellungsabfragen mit einem szenariobasierten Experimentalteil und deckt sowohl Haushalte mit als auch ohne derzeit verfügbare steuerbare Geräte ab.

**Die nentrale Inhaltsbereiche der Umfrage sind dabei, in Reihenfolge ihrer Erhebung:**

- **Primer: Erklärvideo zur SURF (erstellt in Kooperation mit dem AWSi)**
  - ca. 3-minütiges Erklärvideo über die wesentlichen Aspekte der SURF-Plattform, ihrer Funktionsweise und ihres Nutzens für Stromnetz und Teilnehmende.
  
- **Haushaltsausstattung mit steuerbaren Geräten**
  - Besitz und geplante Anschaffung von Wallbox, Wärmepumpe, Batteriespeicher, Photovoltaikanlage und Energiemanagementsystem.

- **Allgemeine Einstellung zur SURF-Plattform**
  - Grundsätzliche Bewertung der Plattform.
  - Teilnahmebereitschaft, differenziert nach Haushalten mit und ohne vorhandene steuerbare Geräte.

- **Szenariobasierter Experimentalteil**
  - Einführung eines hypothetischen Nutzungsszenarios mit aktiver Teilnahme an der SURF-Plattform.
  - Annahme einer automatischen, zeitlich begrenzten Gerätesteuerung zur Behebung von Netzengpässen.
  - Zufällige Variation der jährlichen Häufigkeit von Steuerungseingriffen.
  
- **Eingriffspräferenzen für automatische Steuerung**
  - Entscheidung, welche Geräte grundsätzlich gesteuert werden dürfen.
  - Angabe der maximal akzeptierten Einschränkungen je Gerät (z. B. Ladeverzögerung, Temperaturabweichung, Einspeisereduktion, Restladung).

- **Finanzielle Präferenzen und Zahlungsbereitschaft**
  - Bevorzugte Form der Vergütung.
  - Präferierte Vergütungslogik (pauschal vs. leistungsabhängig).
  - Angabe eines jährlichen Mindestbetrags für die akzeptierten Einschränkungen.
  - Einschätzung der Sicherheit dieser Zahlungsbereitschaft.

- **Steuerungspräferenzen und Vertrauen**
  - Bedeutung individueller Kontroll- und Eingriffsmöglichkeiten.
  - Einstellungen zu automatisierten Entscheidungen der Plattform.
  - Bedarf an zusätzlichen Informationen zur Entscheidungsfindung.

- **Informationsbedarfe und App-Funktionen**
  - Relevanz verschiedener Informationsinhalte (Netzzustand, Komfort-, Finanz- und Netzeffekte).
  - Bevorzugte Darstellungsformen und gewünschte Informationstiefe.

- **Teilnahmemotive**
  - Zentrales Motiv für eine potenzielle Teilnahme an der Plattform.

- **Soziodemografische Merkmale**
  - Alter, Haushaltsgröße, Einkommen, Stromkosten und Stromkostenanteil an Einkommen, Bildung, Geschlecht, Wohnform und Wohnort.


## Datenqualität

Aufgrund des Convenience-Charakters der Befragung[^convenience] ist eine sorgfältige Prüfung der Antwortqualität erforderlich. In diesem Abschnitt werden daher zentrale Indikatoren der Datenqualität systematisch überprüft, tabellarisch aufbereitet und grafisch dargestellt.

[^convenience]: Bei einer Convenience-Stichprobe handelt es sich um eine nicht-zufällige Auswahl von Teilnehmenden, die aufgrund ihrer leichten Erreichbarkeit in die Untersuchung einbezogen werden. Solche Stichproben sind insbesondere für explorative Analysen und Instrumententests geeignet, erlauben jedoch keine statistische Repräsentativität der Ergebnisse für die Grundgesamtheit.

```{r}
#| label: qc-definition-table

qc_definitions <- tibble::tibble(
  Check = c("Speeding", "Straightlining"),
  Indikator = c("Interviewdauer", "Standardabweichung innerhalb von Skalenbatterien"),
  Kriterium = c(
    "Interviewdauer < 1/3 der Median-Dauer",
    "SD über alle Skalenitems = 0"
  ),
  Interpretation = c(
    "Sehr schnelle Bearbeitung deutet auf Satisficing / oberflächliche Bearbeitung hin.",
    "Konstante Antworten über alle Items deuten auf inhaltsloses Durchklicken hin."
  )
)

qc_definitions |> 
  flextable::flextable() |> 
  flextable::autofit()

```

In einem zweiten Schritt werden üblicherweise Fälle entfernt, die Auffälligkeiten im Hinblick auf diese Datenqualitätsmerkmale aufweisen. Da die erhobene Daten jedoch keine derartigen Fälle aufweisen, können sie vollständig in die folgenden Analysen einbezogen werden.

### Speeding

Speeding bezeichnet sehr schnelle Umfragebearbeitung und deutet auf Satisficing, bzw. oberflächliche Bearbeitung der Umfrage, oder sogar "Durchklicken" ohne inhaltliche Auseinandersetzung hin und wird im Rahmen dieser Befragung formal definiert als Interviewdauer < 1/3 der Median-Dauer (Median-Dauer = XXX Min., XXX Sek.). Im Folgenden wird die Anzahl der so als 'Speeder' definierbaren Fälle aufgeführt und visualisiert. Zuvor wird die Bearbeitungsdauer des Online-Surveys visualisiert.

```{r}
#| label: qc-interviewtime-table
#| warning: false
#| message: false

# Bearbeitungszeit in Minuten sicherstellen
surf_check <- surf_check |>
  dplyr::mutate(interview_min = as.numeric(interviewtime) / 60)

# Kennzahlen berechnen
interviewtime_stats <- tibble::tibble(
  Bearbeitungsdauer = c(
    "Minimum (Minuten)",
    "1. Quartil (Q25)",
    "Median (Q50)",
    "Mittelwert",
    "3. Quartil (Q75)",
    "Maximum (Minuten)",
    "Standardabweichung",
    "Speeder-Cutoff (1/3 Median)"
  ),
  Wert = c(
    round(min(surf_check$interview_min, na.rm = TRUE), 2),
    round(quantile(surf_check$interview_min, 0.25, na.rm = TRUE), 2),
    round(median(surf_check$interview_min, na.rm = TRUE), 2),
    round(mean(surf_check$interview_min, na.rm = TRUE), 2),
    round(quantile(surf_check$interview_min, 0.75, na.rm = TRUE), 2),
    round(max(surf_check$interview_min, na.rm = TRUE), 2),
    round(sd(surf_check$interview_min, na.rm = TRUE), 2),
    round(median(surf_check$interview_min, na.rm = TRUE) / 3, 2)
  )
)

# Tabelle ausgeben
flextable::flextable(interviewtime_stats) |>
  flextable::set_header_labels(
    Bearbeitungsdauer = "Bearbeitungsdauer",
    Wert = "Wert"
  ) |>
  flextable::autofit()

```
**Hinweis:** Die Bearbeitungszeit ist in Minuten angegeben. Das Speeder-Kriterium ist definiert als eine Bearbeitungszeit von weniger als einem Drittel des Medians.

```{r}
#| label: qc-time-histogram-all
#| warning: false
#| message: false

surf_check <- surf_check |>
  dplyr::mutate(interview_min = as.numeric(interviewtime) / 60)

median_min     <- median(surf_check$interview_min, na.rm = TRUE)
cutoff_speeder <- median_min / 3

p_all <- ggplot2::ggplot(surf_check, ggplot2::aes(x = interview_min)) +
  ggplot2::geom_histogram(
    bins = 35,
    fill = SURF_PURPLE,
    colour = "white",
    linewidth = 0.2,
    alpha = 0.9
  ) +
  # Median
  ggplot2::geom_vline(
    xintercept = median_min,
    linetype = "dashed",
    linewidth = 0.7,
    colour = SURF_PINK
  ) +
  # Speeder-Kriterium
  ggplot2::geom_vline(
    xintercept = cutoff_speeder,
    linetype = "dotdash",
    linewidth = 0.7,
    colour = SURF_TEXT
  ) +
  ggplot2::labs(
    title = "Verteilung der Bearbeitungszeit (alle Interviews)",
    subtitle = paste0(
      "Median: ", round(median_min, 2),
      " Minuten | Speeder-Kriterium: 1/3 des Medians (",
      round(cutoff_speeder, 2), " Minuten)"
    ),
    x = "Bearbeitungszeit (Minuten)",
    y = "Anzahl Befragte"
  ) +
  theme_surf(base_size = 12)

p_all_branded <- brand_plot_surf(p_all)

ggplot2::ggsave(
  filename = file.path(PLOTS_DIR, "qc_bearbeitungszeit_alle_faelle.png"),
  plot = p_all_branded,
  width = 8, height = 5, dpi = 300
)

p_all_branded

```
**Eingezeichnet:** Der Median der Bearbeitungszeit (gestrichelte Linie) sowie das Speeder-Kriterium als strich-punktierte Linie bei einem Drittel des Medians.

Diese Analyse verdeutlicht, dass eine Reihe von Fällen eine besonders hohe Bearbeitungsdauer aufweisen. Diese rühren vermutlich von Unterbrechnungen während der Bearbeitung des Surveys her. Da diese Fälle sich mit einme Maximum von `r round(max(surf_check$interview_min, na.rm = TRUE), 2)` jedoch im Rahmen annehmbarer Werte bewegen, werden Sie weiterhin in die Analyse eingeschlossen. Gleichzeitig wird eine Reihen von Fällen identifiziert, die eine besonders niedriger Bearbeitungsdauer aufweisen, und potenziell als 'Speeder' gelten können. Der eingezeichnete Cutoff von `r round(median(surf_check$interview_min, na.rm = TRUE) / 3, 1)`, was einem Drittel des Medians von `r round(median(surf_check$interview_min, na.rm = TRUE))` entspricht, verdeutlicht jedoch, dass keine Fälle im Sample unter diese Grenze fallen. Die Daten sind damit, gemäß der hier genutzten Definition, nicht von Speeding betroffen.

### Straightlining

Straightlining wurde als konstantes Antwortmuster über Itembatterien hinweg definiert. Für jede von vier zentralen Skalenbatterien wurde pro Fall die Standardabweichung der Antworten berechnet. Ein Fall wurde als Straightliner klassifiziert, wenn mindestens 60 % der Items einer Batterie beantwortet wurden und die Standardabweichung innerhalb dieser Batterie gleich Null war. Zusätzlich wurde ein Gesamtindikator gebildet, der Straightlining in mindestens einer Batterie abbildet.

```{r}
#| label: qc-straightlining-batterywise
#| message: false
#| warning: false

# ----------------------------
# Straightlining (batterie-spezifisch)
# Definition je Batterie:
# - mind. 60% beantwortet (mindestens 5 Items)
# - SD innerhalb Batterie = 0 (nur wenn >=2 gültige Werte vorhanden)
# Zusätzlich:
# - flag_straightline_any: TRUE wenn in mind. einer Batterie Straightlining
# ----------------------------

# 1) Batterien definieren (Regex pro Batterie)
batteries <- list(
  flex         = "^(flex_)",
  config       = "^(config_)",
  info_content = "^(info_content_)",
  info_form    = "^(info_form_)"
)

# 2) Hilfsfunktion: batterie-spezifische Kennwerte für eine Zeile berechnen
row_straightline_metrics <- function(df_row, vars, min_answered) {
  x <- unlist(df_row[vars], use.names = FALSE)

  # robuste Numerik (falls als character importiert)
  x <- suppressWarnings(as.numeric(x))

  x_valid <- x[!is.na(x)]
  n_ans <- length(x_valid)

  # SD nur sinnvoll bei >=2 gültigen Werten
  sd_x <- if (n_ans >= 2) stats::sd(x_valid) else NA_real_

  flag <- isTRUE(n_ans >= min_answered && !is.na(sd_x) && sd_x == 0)

  list(n_answered = n_ans, sd = sd_x, flag = flag)
}

# 3) Für jede Batterie: Items ermitteln und Variablen anlegen
for (b in names(batteries)) {

  vars_b <- names(surf_check)[stringr::str_detect(names(surf_check), batteries[[b]])]

  # Wenn Batterie im Datensatz nicht vorhanden ist: saubere FALSE/NA-Spalten anlegen und weiter
  if (length(vars_b) == 0) {
    surf_check[[paste0("n_answered_", b)]] <- NA_integer_
    surf_check[[paste0("sd_", b)]] <- NA_real_
    surf_check[[paste0("flag_straightline_", b)]] <- FALSE
    next
  }

  min_answered_b <- max(5, ceiling(length(vars_b) * 0.6))

  # Rowwise-Berechnung pro Batterie
  res_b <- dplyr::rowwise(surf_check) |>
    dplyr::mutate(
      .tmp = list(row_straightline_metrics(
        df_row = dplyr::pick(dplyr::everything()),
        vars = vars_b,
        min_answered = min_answered_b
      )),
      !!paste0("n_answered_", b) := .tmp$n_answered,
      !!paste0("sd_", b) := .tmp$sd,
      !!paste0("flag_straightline_", b) := .tmp$flag
    ) |>
    dplyr::ungroup() |>
    dplyr::select(-.tmp)

  surf_check <- res_b
}

# 4) Gesamtflag: Straightlining in mindestens einer Batterie
flag_vars <- paste0("flag_straightline_", names(batteries))
flag_vars <- flag_vars[flag_vars %in% names(surf_check)]  # Sicherheit

surf_check <- surf_check |>
  dplyr::mutate(
    flag_straightline_any = dplyr::if_any(dplyr::all_of(flag_vars), ~ .x)
  )


```

```{r}
#| label: qc-straightlining-any-table

sl_tab <- surf_check |>
  dplyr::mutate(
    Straightlining = dplyr::if_else(flag_straightline_any, "Straightliner", "Keine Straightliner")
  ) |>
  dplyr::count(Straightlining) |>
  dplyr::mutate(Anteil = round(n / sum(n) * 100, 1))

flextable::flextable(sl_tab) |>
  flextable::set_header_labels(
    Straightlining = "Kategorie",
    n = "Anzahl",
    Anteil = "Anteil (%)"
  ) |>
  flextable::autofit()

```

Auf Basis dieses Qualitätsstandards können ebenfalls keine problematischen Fälle in den erhobenen Daten identifiziert werden.

Weder auf Basis der Bearbeitungsdauer (Speeding) noch hinsichtlich konstanter Antwortmuster (Straightlining) können somit systematisch problematische Fälle identifiziert werden. Die Verteilungen der Bearbeitungszeiten sowie die batterie-spezifischen Straightlining-Indikatoren zeigten keine auffälligen Muster, sodass alle Fälle in die weitere Analyse einbezogen wurden.

# Deskriptive Analyse: Analysenotizen

- Bei hinreichender Samplegröße: Weitere Differenzierung der Besitz- und Anschaffungsgruppen nach Geräten in Besitz/intendierter Geräteanschaffung: [Forschungsfrage:] Welche Formen des Gerätebesitzes sind besonders sensitiv im Hinblick auf Akzeptanz, Partizipation etc?

# Deskriptive Analyse: SURF Convenience Survey

Im Folgenden wird die SURF-Umfrage anhand einer deskriptiven Analyse ausgewertet. Ziel ist es, die zentralen Merkmale der Stichprobe sowie die Verteilungen der inhaltlichen Variablen systematisch darzustellen. Die Analyse erfolgt entlang der in Tabelle X dargestellten Inhaltsblöcke und orientiert sich an der Struktur des Fragebogens.

```{r}
#| label: step1-build-analysis-dataset
#| warning: false
#| message: false

# ------------------------------------------------------------
# Schritt 1: Analyse-Datensatz erstellen (nur inhaltliche Variablen)
# - Whitelist-Ansatz: wir definieren, was INHALT ist, und droppen den Rest
# - erzeugt:
#   * daten_analysis (inhaltliche Variablen)
#   * drop_log (entfernte Variablen + Grund)
#   * var_map (Variable -> Inhaltsblock)
# ------------------------------------------------------------

all_vars <- names(daten)

# 1) Inhaltsvariablen definieren (Whitelist)
#    RandFreq = Experimentalbedingung (wichtig behalten!)
content_regex <- c(
  "^rand_freq$",                # Experimentalbedingung
  "^dev_",                      # Geräteausstattung (DevBox, DevHeat, ...)
  "^acc_(pre|post)$",           # Akzeptanz vor/nach
  "^part_(pre|post)_(real|hypo)$",  # Teilnahmebereitschaft vor/nach
  "^control_",                  # Gerätesteuerung erlaubt? (ControlHeat, ...)
  "^flex_",                     # Eingriffspräferenzen / Flexibilität
  "^fin_(form|structure|amount_year|amount_certainty)", # Vergütung / WTP
  "^restrictions_year$",        # ggf. Filter/inhaltlich (im Fragebogen)
  "^config_",                   # Konfig-/Governance-Batterie
  "^auto_trust",                # Vertrauen / Info-Bedarf
  "^info_content",              # Info-Inhalte (InfoContent[1]...)
  "^info_form",                 # Info-Darstellung (InfoForm[1]...)
  "^info_trust",                # falls vorhanden (im Datensatz sichtbar)
  "^motive$",                   # Teilnahmemotiv
  "^alter$",                    # Alter
  "^pers$",                     # Haushaltsgröße (im Datensatz als Pers)
  "^eink$",                     # Einkommen
  "^strom_rechnung$",           # Stromrechnung
  "^bild$",                     # Bildung
  "^geschl$",                   # Geschlecht
  "^wohn$",                     # Wohnform
  "^wohnort$"                   # Wohnort/Region
)

content_keep <- all_vars[
  stringr::str_detect(all_vars, paste(content_regex, collapse = "|"))
]

# 2) Technische Variablen (werden entfernt, falls nicht schon ausgeschlossen)
technical_regex <- c(
  "^id$",
  "^submitdate$",
  "^lastpage$",
  "^startlanguage$",
  "^seed$",
  "^video_info$",
  "^immersion$",
  "^control_info$",
  "^cheap_talk_script$",
  "^redirect_info_end$",
  "^survey_feedback$",
  "^interviewtime$",
  "^grouptime",     # groupTime#### nach clean_names -> grouptime####
  "time$",           # alles, was auf _time endet
  "^dev_.*_time$"
)

technical_vars <- all_vars[
  stringr::str_detect(all_vars, paste(technical_regex, collapse = "|"))
]

# 3) Endgültige Drop-Liste:
#    Alles, was nicht in content_keep ist, fliegt raus.
#    (Das ist die strengste und sauberste Variante für Schritt 1.)
drop_vars <- setdiff(all_vars, content_keep)

# 4) Analyse-Datensatz
daten_analysis <- daten |>
  dplyr::select(dplyr::all_of(content_keep))

# 5) Mapping: Variable -> Inhaltsblock (für Dokumentation & Plan Schritt 2)
var_map <- tibble::tibble(variable = content_keep) |>
  dplyr::mutate(
    block = dplyr::case_when(
      stringr::str_detect(variable, "^rand_freq$") ~ "03_experiment_randfreq",
      stringr::str_detect(variable, "^dev_") ~ "01_ausstattung",
      stringr::str_detect(variable, "^acc_pre$") ~ "02_akzeptanz_pre",
      stringr::str_detect(variable, "^part_pre_") ~ "02_teilnahme_pre",
      stringr::str_detect(variable, "^control_") ~ "04_geraeteauswahl_steuerung",
      stringr::str_detect(variable, "^flex_") ~ "05_eingriffspraeferenzen",
      stringr::str_detect(variable, "^fin_") | variable == "restrictions_year" ~ "06_verguetung_wtp",
      stringr::str_detect(variable, "^config_") | stringr::str_detect(variable, "^auto_trust") ~ "07_vertrauen_kontrolle",
      stringr::str_detect(variable, "^info_content") | stringr::str_detect(variable, "^info_form") | stringr::str_detect(variable, "^info_trust") ~ "08_information_app",
      stringr::str_detect(variable, "^motive$") ~ "09_motive",
      stringr::str_detect(variable, "^(alter|pers|eink|strom_rechnung|bild|geschl|wohn|wohnort)$") ~ "10_soziodemografie",
      TRUE ~ "zz_unspecified"
    )
  ) |>
  dplyr::arrange(block, variable)

# 6) Drop-Log erstellen (mit Hinweis, ob "technisch erkannt" oder "nicht in Whitelist")
drop_log <- tibble::tibble(variable = drop_vars) |>
  dplyr::mutate(
    drop_reason = dplyr::case_when(
      variable %in% technical_vars ~ "technical/timing/meta",
      TRUE ~ "not-in-content-whitelist"
    )
  ) |>
  dplyr::arrange(drop_reason, variable)

# 7) Report-Ausgabe (kompakt)
# cat("Dimensionen daten (raw): ", paste(dim(daten), collapse = " x "), "\n")
# cat("Dimensionen daten_analysis: ", paste(dim(daten_analysis), collapse = " x "), "\n")
# cat("Behaltene Variablen: ", ncol(daten_analysis), "\n")
# cat("Entfernte Variablen: ", length(drop_vars), "\n")

# 8) Logs speichern (optional, aber sehr empfehlenswert)
readr::write_csv(var_map,  file.path(TABLES_DIR, "00_variable_mapping_blocks.csv"))
readr::write_csv(drop_log, file.path(TABLES_DIR, "00_drop_log_step1.csv"))

# 9) Logs im Report anzeigen (kurz, damit es nicht überläuft)
# knitr::kable(
#   var_map |> dplyr::count(block, name = "n_vars") |> dplyr::arrange(block),
#   caption = "Schritt 1: Anzahl inhaltlicher Variablen pro Inhaltsblock."
# )
# 
# knitr::kable(
#   head(drop_log, 25),
#   caption = "Schritt 1: Beispielhaft entfernte Variablen (erste 25). Vollständige Liste als CSV gespeichert."
# )

```

```{r}
#| label: analysis-roadmap-table
#| warning: false
#| message: false

analysis_roadmap <- tibble::tibble(
  Block = c(
    "01 Geräteausstattung",
    "02 Akzeptanz & Teilnahme",
    "03 Experimentalbedingung",
    "04 Steuerungsbereitschaft",
    "05 Eingriffspräferenzen",
    "06 Vergütung & Zahlungsbereitschaft",
    "07 Vertrauen & Kontrolle",
    "08 Informationsbedarfe",
    "09 Teilnahmemotive",
    "10 Soziodemografie"
  ),
  Inhalt = c(
    "Besitz und geplante Anschaffung steuerbarer Geräte",
    "Allgemeine Einstellung zur SURF-Plattform und Teilnahmebereitschaft",
    "Randomisierte Häufigkeit automatischer Steuerung (RandFreq)",
    "Grundsätzliche Zustimmung zur automatischen Gerätesteuerung",
    "Maximal akzeptierte Einschränkungen je Gerät",
    "Vergütungsform, -logik und jährliche Mindestvergütung",
    "Einstellungen zu Kontrolle, Automatisierung und Vertrauen",
    "Relevanz von Informationsinhalten und Darstellungsformen",
    "Zentrales Motiv für eine potenzielle Teilnahme",
    "Beschreibung der Stichprobe anhand soziodemografischer Merkmale"
  ),
  Variablentypen = c(
    "Kategorial (Single Choice)",
    "Likert / ordinal",
    "Kategorial (experimentell)",
    "Binär (Ja/Nein)",
    "Ordinal / metrisch",
    "Kategorial & metrisch",
    "Likert-Batterien",
    "Likert / Multiple Choice",
    "Single Choice",
    "Metrisch & kategorial"
  ),
  Geplante_Outputs = c(
    "Häufigkeitstabellen, Balkendiagramme",
    "Likert-Verteilungen, Mittel-/Medianwerte",
    "Häufigkeitstabelle, Balkendiagramm",
    "Balkendiagramme je Gerät",
    "Verteilungsplots je Gerät",
    "Balkendiagramme, Histogramme",
    "Likert-Stacked-Plots, Tabellen",
    "Rang- und Relevanzplots",
    "Balkendiagramm",
    "Deskriptive Tabellen & Standardplots"
  ),
  Plotnummerierung = c(
    "01_xx",
    "02_xx",
    "03_xx",
    "04_xx",
    "05_xx",
    "06_xx",
    "07_xx",
    "08_xx",
    "09_xx",
    "10_xx"
  )
)

knitr::kable(
  analysis_roadmap,
  col.names = c("Block", "Inhalt", "Variablentypen", "Geplante Outputs", "Plot-Nr."),
  align = c("l", "l", "l", "l", "c"),
  caption = "Analyse-Roadmap: Inhaltsblöcke, Variablentypen und geplante Auswertungen."
)

```

```{r}
#| label: data cleaning
#| warning: false
#| message: false
#| 
# --- content_keep berechnen (wie bisher) ---
content_keep <- all_vars[
  stringr::str_detect(all_vars, paste(content_regex, collapse = "|"))
]

# --- technische Variablen (wie bisher, aber sauber) ---
technical_regex <- c(
  "^id$","^submitdate$","^lastpage$","^startlanguage$","^seed$",
  "^video_info$","^immersion$","^control_info$","^cheap_talk_script$",
  "^redirect_info_end$","^survey_feedback$",
  "^interviewtime$",
  "^grouptime",
  "_time$"
)

technical_vars <- all_vars[
  stringr::str_detect(all_vars, paste(technical_regex, collapse = "|"))
]

# --- HIER DER FIX: technische Variablen aus content_keep rauswerfen ---
content_keep <- setdiff(content_keep, technical_vars)

# Analyse-Datensatz
daten_analysis <- daten |>
  dplyr::select(dplyr::all_of(content_keep))


```

```{r}
#| label: recode-missing-likert-after-step1
#| include: false
#| warning: false
#| message: false

# ------------------------------------------------------------
# FINAL nach data cleaning (daten_analysis ist final):
# (A) 98/99 -> NA
# (B) Likert 1–5 -> 0–4 (idempotent)
# ------------------------------------------------------------

# A) Missing Codes 98/99 -> NA (nur in daten_analysis)
daten_analysis <- daten_analysis |>
  dplyr::mutate(
    dplyr::across(
      .cols = where(is.numeric),
      .fns  = ~ dplyr::na_if(dplyr::na_if(.x, 98), 99)
    )
  )

# B) Likert-Variablen identifizieren
likert_regex <- c(
  "^acc_(pre|post)$",
  "^part_(pre|post)_(real|hypo)$",
  "^flex_",
  "^config_",
  "^info_content",
  "^info_form",
  "^auto_trust",
  "^info_trust"
)

likert_vars <- names(daten_analysis)[
  stringr::str_detect(names(daten_analysis), paste(likert_regex, collapse = "|"))
]

# Idempotent recode:
# - Nur dann recoden, wenn Werte > 4 vorkommen (typisch: 5 im 1–5-System)
# - Bereits recodierte 0–4 bleiben unverändert
daten_analysis <- daten_analysis |>
  dplyr::mutate(
    dplyr::across(
      .cols = dplyr::all_of(likert_vars),
      .fns  = ~ {
        x <- suppressWarnings(as.numeric(.x))
        if (any(x > 4, na.rm = TRUE)) {
          dplyr::if_else(x %in% 1:5, x - 1, x)
        } else {
          x
        }
      }
    )
  )

```

## SVE

Der erste Analyseblock dient der Beschreibung der Stichprobe anhand der Ausstattung der Haushalte mit steuerbaren Geräten. Die Geräteausstattung ist sowohl ein zentrales inhaltliches Merkmal der Befragung als auch eine wichtige Grundlage für die Interpretation nachfolgender Ergebnisse, da sie maßgeblich die potenziellen Nutzungsmöglichkeiten der SURF-Plattform bestimmt.

```{r}
#| label: block01-devices-overview-table
#| warning: false
#| message: false

# ============================================================
# BLOCK 01: Geräteausstattung (Stichprobenbeschreibung)
# - nutzt deinen SURF Plot Style (theme_surf + brand_plot_surf)
# - ein Übersichtsplot für alle Geräte
# - Export: outputs/plots/01_01_devices_overview.png
# ============================================================

# 1) Gerätevariablen: nur dev_-Inhalte (time ist bereits aus daten_analysis raus)
device_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^dev_")]

if (length(device_vars) == 0) stop("Block 01: Keine dev_-Variablen in daten_analysis gefunden.")

# 2) Gerätnamen (falls Spalten anders heißen: hier anpassen)
device_labels <- c(
  dev_box     = "Wallbox für Elektroauto",
  dev_heat    = "Wärmepumpe",
  dev_battery = "Batteriespeicher",
  dev_pv      = "Photovoltaik-Anlage (Solaranlage)",
  dev_hems    = "Energiemanagementsystem"
)

# 3) Statuslabels (gemäß Umfrage: 1–4)
status_levels <- c(
  "Besitze ich",
  "Plane ich in den nächsten 12 Monaten",
  "Plane ich langfristig",
  "Besitze ich nicht und plane keine Anschaffung"
)

# 4) Long-Format + Rekodierung
devices_long <- daten_analysis |>
  dplyr::select(dplyr::all_of(device_vars)) |>
  tidyr::pivot_longer(
    cols = dplyr::everything(),
    names_to = "device",
    values_to = "status_raw"
  ) |>
  dplyr::mutate(
    device_label = dplyr::if_else(
      device %in% names(device_labels),
      unname(device_labels[device]),
      device
    ),
    status_code = suppressWarnings(as.integer(as.character(status_raw))),
    status = dplyr::case_when(
      status_code == 1 ~ status_levels[1],
      status_code == 2 ~ status_levels[2],
      status_code == 3 ~ status_levels[3],
      status_code == 4 ~ status_levels[4],
      TRUE ~ "Keine Angabe"
    ),
    status = factor(status, levels = c(status_levels, "Keine Angabe"))
  ) |>
  dplyr::select(device_label, status)

# 5) Tabelle (n / %)
device_table <- devices_long |>
  dplyr::count(device_label, status, name = "Anzahl") |>
  dplyr::group_by(device_label) |>
  dplyr::mutate(Anteil = round(Anzahl / sum(Anzahl) * 100, 1)) |>
  dplyr::ungroup() |>
  dplyr::arrange(device_label, match(status, levels(devices_long$status)))

knitr::kable(
  device_table,
  col.names = c("Gerät", "Status", "Anzahl", "Anteil (%)"),
  align = c("l", "l", "r", "r"),
  caption = "Geräteausstattung der Stichprobe: Besitz und geplante Anschaffung steuerbarer Geräte."
)

```

```{r}
#| label: plot-01-devices-overview-plot
#| warning: false
#| message: false

# plot_df muss enthalten: device_label, status, Anteil_prop
# (aus deinem Block-01-Übersichts-Code)
plot_df <- devices_long |>
  dplyr::count(device_label, status, name = "Anzahl") |>
  dplyr::group_by(device_label) |>
  dplyr::mutate(
    Anteil_prop = Anzahl / sum(Anzahl)
  ) |>
  dplyr::ungroup()

p_b01 <- ggplot2::ggplot(
  plot_df,
  ggplot2::aes(y = device_label, x = Anteil_prop, fill = status)
) +
  ggplot2::geom_col(width = 0.75, colour = "white", linewidth = 0.2) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::scale_fill_manual(
    values = c(
      "Besitze ich"                                   = SURF_PURPLE,
      "Plane ich in den nächsten 12 Monaten"          = SURF_PINK,
      "Plane ich langfristig"                         = SURF_MAG,
      "Besitze ich nicht und plane keine Anschaffung" = SURF_GRID,
      "Keine Angabe"                                  = SURF_GRID
    )
  ) +
  ggplot2::labs(
    title = "Geräteausstattung der Stichprobe",
    subtitle = "Besitz und geplante Anschaffung steuerbarer Geräte (Anteile je Gerät)",
    x = "Anteil der Befragten",
    y = NULL,
    fill = NULL
  ) +
  theme_surf(base_size = 12) +
  surf_legend_bottom(nrow = 2, text_size = 9) +
  add_stack_labels(size = 3.0, acc = 0, min_pct = 0.06, colour = "white")

p_b01_branded <- brand_plot_surf(p_b01)

save_plot(plot = p_b01_branded, block = 1, sub = 1, slug = "devices_overview")
p_b01_branded


```

### SVE Gruppen

Auf Basis der Geräteausstattung und der angegebenen Anschaffungsabsichten lassen sich vier Haushaltsgruppen unterscheiden. Ein Teil der Stichprobe verfügt bereits über mindestens ein steuerbares Gerät und wird als aktive Flexibilitätsnutzer eingeordnet. Weitere Haushalte planen die Anschaffung entsprechender Geräte kurzfristig oder langfristig, während ein verbleibender Anteil weder Geräte besitzt noch Anschaffungsabsichten angibt. Diese Gruppierung bildet eine zentrale Grundlage für die Interpretation der nachfolgenden Analysen.

```{r}
#| label: b01-device-groups-create
#| warning: false
#| message: false

# ------------------------------------------------------------
# Gerätebesitzgruppen auf Haushaltsebene
# ------------------------------------------------------------

# Gerätevariablen (Inhalte)
device_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^dev_")]

# Long-Format: Haushalt × Gerät
devices_long_hh <- daten_analysis |>
  dplyr::select(dplyr::all_of(device_vars)) |>
  dplyr::mutate(hh_id = dplyr::row_number()) |>
  tidyr::pivot_longer(
    cols = -hh_id,
    names_to = "device",
    values_to = "status_raw"
  ) |>
  dplyr::mutate(
    status_code = suppressWarnings(as.integer(as.character(status_raw)))
  )

# Haushaltsweise Flags
device_group_flags <- devices_long_hh |>
  dplyr::group_by(hh_id) |>
  dplyr::summarise(
    has_device        = any(status_code == 1, na.rm = TRUE),
    plans_shortterm   = any(status_code == 2, na.rm = TRUE),
    plans_longterm    = any(status_code == 3, na.rm = TRUE),
    .groups = "drop"
  )

# Gruppenvariable (Prioritätslogik!)
device_groups <- device_group_flags |>
  dplyr::mutate(
    device_group = dplyr::case_when(
      has_device ~ "Gerätebesitzer",
      !has_device & plans_shortterm ~ "Kurzfristige Adopter",
      !has_device & !plans_shortterm & plans_longterm ~ "Langfristig Interessierte",
      TRUE ~ "Nicht-Adopter"
    ),
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  )

# Gruppenvariable an daten_analysis anhängen
daten_analysis <- daten_analysis |>
  dplyr::mutate(
    device_group = device_groups$device_group
  )

```

```{r}
#| label: b01-device-groups-plot
#| warning: false
#| message: false

# Daten für Plot
device_group_plot <- daten_analysis |>
  dplyr::count(device_group, name = "Anzahl") |>
  dplyr::mutate(
    Anteil = Anzahl / sum(Anzahl)
  )

# Plot
p_groups <- ggplot2::ggplot(
  device_group_plot,
  ggplot2::aes(x = device_group, y = Anteil)
) +
  ggplot2::geom_col(
    fill = SURF_PURPLE,
    width = 0.65
  ) +
  ggplot2::scale_y_continuous(
    labels = scales::percent_format(accuracy = 1)
  ) +
  ggplot2::labs(
    title = "Gerätebesitz- und Anschaffungsgruppen in der Stichprobe",
    subtitle = "Haushaltsbezogene Einteilung auf Basis von Besitz und Anschaffungsintention",
    x = NULL,
    y = "Anteil der Befragten"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)
  )

p_groups_branded <- brand_plot_surf(p_groups)

# Export
save_plot(
  plot  = p_groups_branded,
  block = 1,
  sub   = 2,
  slug  = "device_groups"
)

p_groups_branded

```

## Akzeptanz

### Akzeptanz zu Beginn

```{r}
#| label: table-02-01-acc-pre-groups
#| warning: false
#| message: false

# ------------------------------------------------------------
# Akzeptanz PRE – Tabelle (PNG only, PPT-tauglich)
# ------------------------------------------------------------

acc_pre_groups_table <- daten_analysis |>
  dplyr::select(device_group, acc_pre) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::transmute(device_group = "Gesamtstichprobe", acc_pre = acc_pre)
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(acc_pre), .groups = "drop") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::arrange(device_group) |>
  dplyr::transmute(
    Gruppe = as.character(device_group),
    `n (gültig)` = n,
    Mittelwert = round(mean, 2),
    SD = round(sd, 2),
    SE = round(se, 2),
    `95%-KI (unten)` = round(ymin, 2),
    `95%-KI (oben)`  = round(ymax, 2)
  )

ft_acc_pre <- make_ft_surf(
  data = acc_pre_groups_table,
  caption = "Akzeptanz der SURF-Plattform vor dem Szenario (Mittelwerte mit 95%-KI).",
  align_left_cols  = "Gruppe",
  align_right_cols = setdiff(names(acc_pre_groups_table), "Gruppe"),
  font_size = 10
)

# Im Report anzeigen
ft_acc_pre

# PNG speichern (tight)
export_flextable_png(
  ft = ft_acc_pre,
  filename_base = "02_01_acceptance_pre_groups_table",
  tables_dir = TABLES_DIR,
  res = 300
)

```

```{r}
#| label: plot-02-01-acc-pre-groups
#| warning: false
#| message: false

acc_pre_groups <- daten_analysis |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::mutate(device_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(acc_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_pre_groups <- max(c(acc_pre_groups$label_y, acc_pre_groups$ymax, 4), na.rm = TRUE) + 0.15

p_acc_pre_groups <- ggplot2::ggplot(acc_pre_groups, ggplot2::aes(x = device_group, y = mean)) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Akzeptanz der SURF-Plattform (vor Szenario)",
    subtitle = "Durchschnittswerte (mit 95%-Konfidenzintervallen) gesamt und nach Gerätebesitzgruppen",
    x = NULL,
    y = "Akzeptanz (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_pre_groups), clip = "off")

p_acc_pre_groups_branded <- brand_plot_surf(p_acc_pre_groups)
save_plot(p_acc_pre_groups_branded, 2, 1, "acceptance_pre_groups")
p_acc_pre_groups_branded

```

```{r}
#| label: plot-02-02-acc-pre-experiment
#| warning: false
#| message: false

acc_pre_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(acc_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_pre_exp <- max(c(acc_pre_exp$label_y, acc_pre_exp$ymax, 4), na.rm = TRUE) + 0.15

p_acc_pre_exp <- ggplot2::ggplot(
  acc_pre_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Akzeptanz (vor Szenario) nach Experimentalbedingung und Gerätebesitzgruppen",
    subtitle = "Mittelwerte mit 95%-Konfidenzintervallen",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Akzeptanz (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_pre_exp), clip = "off")

p_acc_pre_exp_branded <- brand_plot_surf(p_acc_pre_exp)
save_plot(p_acc_pre_exp_branded, 2, 2, "acceptance_pre_experiment_groups")
p_acc_pre_exp_branded

```

### Akzeptanz am Ende

```{r}
#| label: plot-02-03-acc-post-groups
#| warning: false
#| message: false

acc_post_groups <- daten_analysis |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::mutate(device_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(acc_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_post_groups <- max(c(acc_post_groups$label_y, acc_post_groups$ymax, 4), na.rm = TRUE) + 0.15

p_acc_post_groups <- ggplot2::ggplot(acc_post_groups, ggplot2::aes(x = device_group, y = mean)) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Akzeptanz der SURF-Plattform (nach Szenario)",
    subtitle = "Durchschnittswerte (mit 95%-Konfidenzintervallen) gesamt und nach Gerätebesitzgruppen",
    x = NULL,
    y = "Akzeptanz (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_post_groups), clip = "off")

p_acc_post_groups_branded <- brand_plot_surf(p_acc_post_groups)
save_plot(p_acc_post_groups_branded, 2, 3, "acceptance_post_groups")
p_acc_post_groups_branded

```

```{r}
#| label: plot-02-04-acc-post-experiment
#| warning: false
#| message: false

acc_post_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(acc_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_post_exp <- max(c(acc_post_exp$label_y, acc_post_exp$ymax, 4), na.rm = TRUE) + 0.15

p_acc_post_exp <- ggplot2::ggplot(
  acc_post_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Akzeptanz (nach Szenario) nach Experimentalbedingung und Gerätebesitzgruppen",
    subtitle = "Mittelwerte mit 95%-Konfidenzintervallen",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Akzeptanz (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_post_exp), clip = "off")

p_acc_post_exp_branded <- brand_plot_surf(p_acc_post_exp)
save_plot(p_acc_post_exp_branded, 2, 4, "acceptance_post_experiment_groups")
p_acc_post_exp_branded

```

### Akzeptanz Differenz Beginn-Ende

```{r}
#| label: acc-difference-create
#| warning: false
#| message: false

daten_analysis <- daten_analysis |>
  dplyr::mutate(
    acc_diff = acc_post - acc_pre
  )

```

```{r}
#| label: plot-02-03-acc-diff-groups
#| warning: false
#| message: false

# Sicherstellen: Diff existiert
daten_analysis <- daten_analysis |>
  dplyr::mutate(acc_diff = acc_post - acc_pre)

acc_diff_groups <- daten_analysis |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::mutate(device_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(acc_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

# Headroom: CI + Label niemals abschneiden (wie bei POST, nur symmetrisch um 0)
y_top_diff_groups <- max(c(acc_diff_groups$label_y, acc_diff_groups$ymax), na.rm = TRUE) + 0.15
y_bot_diff_groups <- min(c(acc_diff_groups$ymin), na.rm = TRUE) - 0.15
y_abs_diff_groups <- max(abs(c(y_bot_diff_groups, y_top_diff_groups, -1, 1)), na.rm = TRUE)

p_acc_diff_groups <- ggplot2::ggplot(acc_diff_groups, ggplot2::aes(x = device_group, y = mean)) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Veränderung der Akzeptanz durch das Szenario",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen) gesamt und nach Gerätebesitzgruppen",
    x = NULL,
    y = "Δ Akzeptanz (POST − PRE)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_diff_groups, y_abs_diff_groups), clip = "off")

p_acc_diff_groups_branded <- brand_plot_surf(p_acc_diff_groups)
save_plot(p_acc_diff_groups_branded, 2, 3, "acceptance_diff_groups")
p_acc_diff_groups_branded


```

```{r}
#| label: plot-02-04-acc-diff-experiment
#| warning: false
#| message: false

# Sicherstellen: Diff existiert
daten_analysis <- daten_analysis |>
  dplyr::mutate(acc_diff = acc_post - acc_pre)

acc_diff_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(acc_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

# Headroom: CI + Label niemals abschneiden (wie bei POST, nur symmetrisch um 0)
y_top_diff_exp <- max(c(acc_diff_exp$label_y, acc_diff_exp$ymax), na.rm = TRUE) + 0.15
y_bot_diff_exp <- min(c(acc_diff_exp$ymin), na.rm = TRUE) - 0.15
y_abs_diff_exp <- max(abs(c(y_bot_diff_exp, y_top_diff_exp, -1, 1)), na.rm = TRUE)

p_acc_diff_exp <- ggplot2::ggplot(acc_diff_exp, ggplot2::aes(x = rand_freq, y = mean)) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Veränderung der Akzeptanz nach Experimentalbedingung und Gerätebesitzgruppen",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen)",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Δ Akzeptanz (POST − PRE)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_diff_exp, y_abs_diff_exp), clip = "off")

p_acc_diff_exp_branded <- brand_plot_surf(p_acc_diff_exp)
save_plot(p_acc_diff_exp_branded, 2, 4, "acceptance_diff_experiment_groups")
p_acc_diff_exp_branded

```

## Partizipationsintention (PI)

```{r}
#| label: part-owner-group-create
#| warning: false
#| message: false

daten_analysis <- daten_analysis |>
  dplyr::mutate(
    # Besitzstatus: Gerätebesitzer vs Nicht-Besitzer
    owner_group = dplyr::case_when(
      device_group == "Gerätebesitzer" ~ "Gerätebesitzer",
      device_group %in% c("Kurzfristige Adopter","Langfristig Interessierte","Nicht-Adopter") ~ "Nicht-Besitzer",
      TRUE ~ NA_character_
    ),
    owner_group = factor(owner_group, levels = c("Gerätebesitzer", "Nicht-Besitzer")),

    # ------------------------------------------------------------
    # WICHTIGER FIX:
    # PI wurde 2x erhoben: real (Besitzer) und hypo (Nicht-Besitzer)
    # => gemeinsame PRE/POST Variable bauen
    # (achte darauf, dass die richtigen Spaltennamen existieren)
    # ------------------------------------------------------------
    part_pre = dplyr::case_when(
      owner_group == "Gerätebesitzer" ~ part_pre_real,
      owner_group == "Nicht-Besitzer" ~ part_pre_hypo,
      TRUE ~ NA_real_
    ),
    part_post = dplyr::case_when(
      owner_group == "Gerätebesitzer" ~ part_post_real,
      owner_group == "Nicht-Besitzer" ~ part_post_hypo,
      TRUE ~ NA_real_
    ),

    # Differenz (POST – PRE) auf Basis der gemeinsamen Variable
    part_diff = dplyr::if_else(!is.na(part_post) & !is.na(part_pre), part_post - part_pre, NA_real_)
  )

```

### PI zu Beginn

```{r}
#| label: plot-03-01-part-pre-groups
#| warning: false
#| message: false

part_pre_groups <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::filter(!is.na(owner_group)) |>
      dplyr::mutate(owner_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gesamtstichprobe", "Gerätebesitzer", "Nicht-Besitzer"))
  ) |>
  dplyr::group_by(owner_group) |>
  dplyr::summarise(mean_ci_n(part_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_pre_groups <- max(c(part_pre_groups$label_y, part_pre_groups$ymax, 4), na.rm = TRUE) + 0.15

p_part_pre_groups <- ggplot2::ggplot(
  part_pre_groups,
  ggplot2::aes(x = owner_group, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft vor dem Szenario",
    subtitle = "Gemeinsame PI-Skala (REAL bei Besitzern, HYPO bei Nicht-Besitzern) – Mittelwerte mit 95%-KI",
    x = NULL,
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_pre_groups), clip = "off")

p_part_pre_groups_branded <- brand_plot_surf(p_part_pre_groups)

save_plot(
  plot  = p_part_pre_groups_branded,
  block = 3,
  sub   = 1,
  slug  = "participation_pre_owner"
)

p_part_pre_groups_branded

```

```{r}
#| label: plot-03-13-part-pre-combined
#| warning: false
#| message: false

combined_levels <- c(
  "Gesamtstichprobe",
  "Gerätebesitzer",
  "Nicht-Besitzer (agg.)",
  "Kurzfristige Adopter",
  "Langfristig Interessierte",
  "Nicht-Adopter"
)

part_pre_combined <- dplyr::bind_rows(
  daten_analysis |> dplyr::mutate(group_combined = "Gesamtstichprobe"),
  daten_analysis |> dplyr::filter(device_group == "Gerätebesitzer") |> dplyr::mutate(group_combined = "Gerätebesitzer"),
  daten_analysis |> dplyr::filter(owner_group == "Nicht-Besitzer") |> dplyr::mutate(group_combined = "Nicht-Besitzer (agg.)"),
  daten_analysis |>
    dplyr::filter(device_group %in% c("Kurzfristige Adopter", "Langfristig Interessierte", "Nicht-Adopter")) |>
    dplyr::mutate(group_combined = device_group)
) |>
  dplyr::mutate(group_combined = factor(group_combined, levels = combined_levels)) |>
  dplyr::group_by(group_combined) |>
  dplyr::summarise(mean_ci_n(part_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

# Headroom
y_top_part_pre_combined <- max(
  c(part_pre_combined$label_y, part_pre_combined$ymax, 4),
  na.rm = TRUE
) + 0.35

# Gemeinsame (hohe) Box-Höhe: minimal näher an den oberen Rand
annot_y_pre <- y_top_part_pre_combined + 0.3

subtitle_pre <- paste(
  "Partizipationsintention Real oder Hypothetisch",
  "Nach Aggregat, Adoption, und Adoptionsintention",
  sep = "\n"
)

p_part_pre_combined <- ggplot2::ggplot(
  part_pre_combined,
  ggplot2::aes(x = group_combined, y = mean)
) +
  # visuelle Trennung (deutlich)
  ggplot2::geom_vline(
    xintercept = 3.5,
    colour = SURF_GRID,
    linewidth = 1.1
  ) +

  # Linke Box (Aggregat / Besitz vs. Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 2.5,                     # exakt zwischen Kategorie 2 und 3
    y = annot_y_pre,
    label = "Besitz vs. Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  # Rechte Box (Differenzierung Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 5.0,
    y = annot_y_pre,
    label = "Differenzierung Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft vor dem Szenario",
    subtitle = subtitle_pre,
    x = NULL,
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 15, hjust = 1),

    # mehr Abstand zwischen (Unter-)Titel und Panel
    plot.title.position = "plot",
    plot.subtitle = ggplot2::element_text(
      margin = ggplot2::margin(b = 14)
    ),

    # mehr Luft oben + rechts (Logo + Labels)
    plot.margin = ggplot2::margin(18, 30, 18, 12)
  ) +
  ggplot2::scale_x_discrete(drop = FALSE) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(
    ylim = c(0, y_top_part_pre_combined),
    clip = "off"
  )

p_part_pre_combined_branded <- brand_plot_surf(p_part_pre_combined)

save_plot(
  plot  = p_part_pre_combined_branded,
  block = 3,
  sub   = 13,
  slug  = "participation_pre_combined"
)

p_part_pre_combined_branded

```

#### Nach Adoptionsstatus

```{r}
#| label: plot-03-02-part-pre-experiment
#| warning: false
#| message: false

part_pre_exp <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gerätebesitzer", "Nicht-Besitzer")),
    rand_freq   = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(owner_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_pre_exp <- max(c(part_pre_exp$label_y, part_pre_exp$ymax, 4), na.rm = TRUE) + 0.15

p_part_pre_exp <- ggplot2::ggplot(
  part_pre_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ owner_group, nrow = 1) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft vor dem Szenario nach Experimentalbedingung",
    subtitle = "Gemeinsame PI-Skala (REAL bei Besitzern, HYPO bei Nicht-Besitzern) – Mittelwerte mit 95%-KI",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_pre_exp), clip = "off")

p_part_pre_exp_branded <- brand_plot_surf(p_part_pre_exp)

save_plot(
  plot  = p_part_pre_exp_branded,
  block = 3,
  sub   = 2,
  slug  = "participation_pre_experiment_owner"
)

p_part_pre_exp_branded

```

#### Nach Adoptionsstatus und -intention

```{r}
#| label: plot-03-08-part-pre-devicegroups-experiment
#| warning: false
#| message: false

part_pre_devicegroups_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_pre), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_pre_devicegroups_exp <- max(c(part_pre_devicegroups_exp$label_y, part_pre_devicegroups_exp$ymax, 4), na.rm = TRUE) + 0.15

p_part_pre_devicegroups_exp <- ggplot2::ggplot(
  part_pre_devicegroups_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft vor dem Szenario nach Experimentalbedingung",
    subtitle = "Gemeinsame PI-Skala (REAL/HYPO) – Geräte-Untergruppen (Mittelwerte mit 95%-KI)",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_pre_devicegroups_exp), clip = "off")

p_part_pre_devicegroups_exp_branded <- brand_plot_surf(p_part_pre_devicegroups_exp)

save_plot(
  plot  = p_part_pre_devicegroups_exp_branded,
  block = 3,
  sub   = 8,
  slug  = "participation_pre_devicegroups_experiment"
)

p_part_pre_devicegroups_exp_branded

```

### PI am Ende

```{r}
#| label: plot-03-03-part-post-groups
#| warning: false
#| message: false

part_post_groups <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::filter(!is.na(owner_group)) |>
      dplyr::mutate(owner_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gesamtstichprobe", "Gerätebesitzer", "Nicht-Besitzer"))
  ) |>
  dplyr::group_by(owner_group) |>
  dplyr::summarise(mean_ci_n(part_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_post_groups <- max(c(part_post_groups$label_y, part_post_groups$ymax, 4), na.rm = TRUE) + 0.15

p_part_post_groups <- ggplot2::ggplot(
  part_post_groups,
  ggplot2::aes(x = owner_group, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft nach dem Szenario",
    subtitle = "Gemeinsame PI-Skala (REAL bei Besitzern, HYPO bei Nicht-Besitzern) – Mittelwerte mit 95%-KI",
    x = NULL,
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_post_groups), clip = "off")

p_part_post_groups_branded <- brand_plot_surf(p_part_post_groups)

save_plot(
  plot  = p_part_post_groups_branded,
  block = 3,
  sub   = 3,
  slug  = "participation_post_owner"
)

p_part_post_groups_branded

```

```{r}
#| label: plot-03-09-part-post-devicegroups
#| warning: false
#| message: false

part_post_devicegroups <- daten_analysis |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::mutate(device_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(part_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_post_devicegroups <- max(c(part_post_devicegroups$label_y, part_post_devicegroups$ymax, 4), na.rm = TRUE) + 0.15

p_part_post_devicegroups <- ggplot2::ggplot(
  part_post_devicegroups,
  ggplot2::aes(x = device_group, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft nach dem Szenario",
    subtitle = "Gemeinsame PI-Skala (REAL/HYPO) – Gesamtstichprobe und Geräte-Untergruppen (Mittelwerte mit 95%-KI)",
    x = NULL,
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_post_devicegroups), clip = "off")

p_part_post_devicegroups_branded <- brand_plot_surf(p_part_post_devicegroups)

save_plot(
  plot  = p_part_post_devicegroups_branded,
  block = 3,
  sub   = 9,
  slug  = "participation_post_devicegroups"
)

p_part_post_devicegroups_branded

```

```{r}
#| label: plot-03-13-part-post-combined
#| warning: false
#| message: false

combined_levels <- c(
  "Gesamtstichprobe",
  "Gerätebesitzer",
  "Nicht-Besitzer (agg.)",
  "Kurzfristige Adopter",
  "Langfristig Interessierte",
  "Nicht-Adopter"
)

part_post_combined <- dplyr::bind_rows(
  daten_analysis |> dplyr::mutate(group_combined = "Gesamtstichprobe"),
  daten_analysis |> dplyr::filter(device_group == "Gerätebesitzer") |> dplyr::mutate(group_combined = "Gerätebesitzer"),
  daten_analysis |> dplyr::filter(owner_group == "Nicht-Besitzer") |> dplyr::mutate(group_combined = "Nicht-Besitzer (agg.)"),
  daten_analysis |>
    dplyr::filter(device_group %in% c("Kurzfristige Adopter", "Langfristig Interessierte", "Nicht-Adopter")) |>
    dplyr::mutate(group_combined = device_group)
) |>
  dplyr::mutate(group_combined = factor(group_combined, levels = combined_levels)) |>
  dplyr::group_by(group_combined) |>
  dplyr::summarise(mean_ci_n(part_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

# Headroom
y_top_part_post_combined <- max(
  c(part_post_combined$label_y, part_post_combined$ymax, 4),
  na.rm = TRUE
) + 0.35

# Gemeinsame (hohe) Box-Höhe: minimal näher an den oberen Rand
annot_y_post <- y_top_part_post_combined + 0.3

subtitle_post <- paste(
  "Partizipationsintention Real oder Hypothetisch",
  "Nach Aggregat, Adoption, und Adoptionsintention",
  sep = "\n"
)

p_part_post_combined <- ggplot2::ggplot(
  part_post_combined,
  ggplot2::aes(x = group_combined, y = mean)
) +
  # visuelle Trennung (deutlich)
  ggplot2::geom_vline(
    xintercept = 3.5,
    colour = SURF_GRID,
    linewidth = 1.1
  ) +

  # Linke Box (Aggregat / Besitz vs. Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 2.5,                     # exakt zwischen Kategorie 2 und 3
    y = annot_y_post,
    label = "Besitz vs. Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  # Rechte Box (Differenzierung Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 5.0,
    y = annot_y_post,
    label = "Differenzierung Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft nach dem Szenario",
    subtitle = subtitle_post,
    x = NULL,
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 15, hjust = 1),

    # mehr Abstand zwischen (Unter-)Titel und Panel
    plot.title.position = "plot",
    plot.subtitle = ggplot2::element_text(
      margin = ggplot2::margin(b = 14)
    ),

    # mehr Luft oben + rechts (Logo + Labels)
    plot.margin = ggplot2::margin(18, 30, 18, 12)
  ) +
  ggplot2::scale_x_discrete(drop = FALSE) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(
    ylim = c(0, y_top_part_post_combined),
    clip = "off"
  )

p_part_post_combined_branded <- brand_plot_surf(p_part_post_combined)

save_plot(
  plot  = p_part_post_combined_branded,
  block = 3,
  sub   = 13,
  slug  = "participation_post_combined"
)

p_part_post_combined_branded

```

#### Nach Adoptionsstatus

```{r}
#| label: plot-03-04-part-post-experiment
#| warning: false
#| message: false

part_post_exp <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gerätebesitzer", "Nicht-Besitzer")),
    rand_freq   = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(owner_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_post_exp <- max(c(part_post_exp$label_y, part_post_exp$ymax, 4), na.rm = TRUE) + 0.15

p_part_post_exp <- ggplot2::ggplot(
  part_post_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ owner_group, nrow = 1) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft nach dem Szenario nach Experimentalbedingung",
    subtitle = "Gemeinsame PI-Skala (REAL bei Besitzern, HYPO bei Nicht-Besitzern) – Mittelwerte mit 95%-KI",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_post_exp), clip = "off")

p_part_post_exp_branded <- brand_plot_surf(p_part_post_exp)

save_plot(
  plot  = p_part_post_exp_branded,
  block = 3,
  sub   = 4,
  slug  = "participation_post_experiment_owner"
)

p_part_post_exp_branded

```

#### Nach Adoptionsstatus und -intention

```{r}
#| label: plot-03-10-part-post-devicegroups-experiment
#| warning: false
#| message: false

part_post_devicegroups_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_post), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_post_devicegroups_exp <- max(c(part_post_devicegroups_exp$label_y, part_post_devicegroups_exp$ymax, 4), na.rm = TRUE) + 0.15

p_part_post_devicegroups_exp <- ggplot2::ggplot(
  part_post_devicegroups_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Teilnahmebereitschaft nach dem Szenario nach Experimentalbedingung",
    subtitle = "Gemeinsame PI-Skala (REAL/HYPO) – Geräte-Untergruppen (Mittelwerte mit 95%-KI)",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Teilnahmeintention (0–4)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::scale_y_continuous(breaks = 0:4) +
  ggplot2::coord_cartesian(ylim = c(0, y_top_part_post_devicegroups_exp), clip = "off")

p_part_post_devicegroups_exp_branded <- brand_plot_surf(p_part_post_devicegroups_exp)

save_plot(
  plot  = p_part_post_devicegroups_exp_branded,
  block = 3,
  sub   = 10,
  slug  = "participation_post_devicegroups_experiment"
)

p_part_post_devicegroups_exp_branded

```

### PI Differenz Beginn-Ende

```{r}
#| label: plot-03-05-part-diff-groups
#| warning: false
#| message: false

part_diff_groups <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::filter(!is.na(owner_group)) |>
      dplyr::mutate(owner_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gesamtstichprobe", "Gerätebesitzer", "Nicht-Besitzer"))
  ) |>
  dplyr::group_by(owner_group) |>
  dplyr::summarise(mean_ci_n(part_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_diff_groups <- max(c(part_diff_groups$label_y, part_diff_groups$ymax), na.rm = TRUE) + 0.15
y_bot_part_diff_groups <- min(part_diff_groups$ymin, na.rm = TRUE) - 0.15
y_abs_part_diff_groups <- max(abs(c(y_bot_part_diff_groups, y_top_part_diff_groups, -1, 1)), na.rm = TRUE)

p_part_diff_groups <- ggplot2::ggplot(
  part_diff_groups,
  ggplot2::aes(x = owner_group, y = mean)
) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Veränderung der Teilnahmebereitschaft durch das Szenario",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen)",
    x = NULL,
    y = "Δ Teilnahmeintention (POST − PRE)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_part_diff_groups, y_abs_part_diff_groups), clip = "off")

p_part_diff_groups_branded <- brand_plot_surf(p_part_diff_groups)

save_plot(
  plot  = p_part_diff_groups_branded,
  block = 3,
  sub   = 5,
  slug  = "participation_difference_owner"
)

p_part_diff_groups_branded

```

```{r}
#| label: plot-03-11-part-diff-devicegroups
#| warning: false
#| message: false

part_diff_devicegroups <- daten_analysis |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::bind_rows(
    daten_analysis |>
      dplyr::mutate(device_group = "Gesamtstichprobe")
  ) |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gesamtstichprobe",
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    )
  ) |>
  dplyr::group_by(device_group) |>
  dplyr::summarise(mean_ci_n(part_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_diff_devicegroups <- max(c(part_diff_devicegroups$label_y, part_diff_devicegroups$ymax), na.rm = TRUE) + 0.15
y_bot_part_diff_devicegroups <- min(part_diff_devicegroups$ymin, na.rm = TRUE) - 0.15
y_abs_part_diff_devicegroups <- max(abs(c(y_bot_part_diff_devicegroups, y_top_part_diff_devicegroups, -1, 1)), na.rm = TRUE)

p_part_diff_devicegroups <- ggplot2::ggplot(
  part_diff_devicegroups,
  ggplot2::aes(x = device_group, y = mean)
) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Veränderung der Teilnahmebereitschaft durch das Szenario",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen) – Gesamtstichprobe und Geräte-Untergruppen",
    x = NULL,
    y = "Δ Teilnahmeintention (POST − PRE)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(axis.text.x = ggplot2::element_text(angle = 15, hjust = 1)) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_part_diff_devicegroups, y_abs_part_diff_devicegroups), clip = "off")

p_part_diff_devicegroups_branded <- brand_plot_surf(p_part_diff_devicegroups)

save_plot(
  plot  = p_part_diff_devicegroups_branded,
  block = 3,
  sub   = 11,
  slug  = "participation_diff_devicegroups"
)

p_part_diff_devicegroups_branded

```

```{r}
#| label: plot-03-15-part-diff-combined
#| warning: false
#| message: false

combined_levels <- c(
  "Gesamtstichprobe",
  "Gerätebesitzer",
  "Nicht-Besitzer (agg.)",
  "Kurzfristige Adopter",
  "Langfristig Interessierte",
  "Nicht-Adopter"
)

part_diff_combined <- dplyr::bind_rows(
  daten_analysis |> dplyr::mutate(group_combined = "Gesamtstichprobe"),
  daten_analysis |> dplyr::filter(device_group == "Gerätebesitzer") |> dplyr::mutate(group_combined = "Gerätebesitzer"),
  daten_analysis |> dplyr::filter(owner_group == "Nicht-Besitzer") |> dplyr::mutate(group_combined = "Nicht-Besitzer (agg.)"),
  daten_analysis |>
    dplyr::filter(device_group %in% c("Kurzfristige Adopter", "Langfristig Interessierte", "Nicht-Adopter")) |>
    dplyr::mutate(group_combined = device_group)
) |>
  dplyr::mutate(group_combined = factor(group_combined, levels = combined_levels)) |>
  dplyr::group_by(group_combined) |>
  dplyr::summarise(mean_ci_n(part_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

# Symmetrische Headroom-Logik (Diff-Plot)
y_top_part_diff_combined <- max(c(part_diff_combined$label_y, part_diff_combined$ymax), na.rm = TRUE) + 0.15
y_bot_part_diff_combined <- min(part_diff_combined$ymin, na.rm = TRUE) - 0.15
y_abs_part_diff_combined <- max(abs(c(y_bot_part_diff_combined, y_top_part_diff_combined, -1, 1)), na.rm = TRUE)

# Box-Position oberhalb des Panels (clip = "off")
annot_y_diff <- y_abs_part_diff_combined + 0.0

subtitle_diff <- paste(
  "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen)",
  "Nach Aggregat, Adoption, und Adoptionsintention",
  sep = "\n"
)

p_part_diff_combined <- ggplot2::ggplot(
  part_diff_combined,
  ggplot2::aes(x = group_combined, y = mean)
) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +

  # visuelle Trennung (deutlich)
  ggplot2::geom_vline(
    xintercept = 3.5,
    colour = SURF_GRID,
    linewidth = 1.1
  ) +

  # Linke Box (Aggregat / Besitz vs. Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 2.5,                     # exakt zwischen Kategorie 2 und 3
    y = annot_y_diff,
    label = "Besitz vs. Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  # Rechte Box (Differenzierung Nicht-Besitz)
  ggplot2::annotate(
    "label",
    x = 5.0,
    y = annot_y_diff,
    label = "Differenzierung Nicht-Besitz",
    hjust = 0.5,
    vjust = 1,
    size = 3.0,
    colour = SURF_TEXT,
    fill = "white",
    label.size = 0.35
  ) +

  ggplot2::geom_point(colour = SURF_PURPLE, size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.15,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 3.1,
    vjust = 0
  ) +
  ggplot2::labs(
    title = "Veränderung der Teilnahmebereitschaft durch das Szenario",
    subtitle = subtitle_diff,
    x = NULL,
    y = "Δ Teilnahmeintention (POST − PRE)"
  ) +
  theme_surf(base_size = 12) +
  ggplot2::theme(
    axis.text.x = ggplot2::element_text(angle = 15, hjust = 1),

    # mehr Abstand zwischen (Unter-)Titel und Panel
    plot.title.position = "plot",
    plot.subtitle = ggplot2::element_text(
      margin = ggplot2::margin(b = 14)
    ),

    # mehr Luft oben + rechts (Logo + Labels)
    plot.margin = ggplot2::margin(18, 30, 18, 12)
  ) +
  ggplot2::scale_x_discrete(drop = FALSE) +
  ggplot2::coord_cartesian(
    ylim = c(-y_abs_part_diff_combined, y_abs_part_diff_combined),
    clip = "off"
  )

p_part_diff_combined_branded <- brand_plot_surf(p_part_diff_combined)

save_plot(
  plot  = p_part_diff_combined_branded,
  block = 3,
  sub   = 15,
  slug  = "participation_diff_combined"
)

p_part_diff_combined_branded

```

#### Nach Adoptionsstatus

```{r}
#| label: plot-03-06-part-diff-experiment
#| warning: false
#| message: false

part_diff_exp <- daten_analysis |>
  dplyr::filter(!is.na(owner_group)) |>
  dplyr::mutate(
    owner_group = factor(owner_group, levels = c("Gerätebesitzer", "Nicht-Besitzer")),
    rand_freq   = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(owner_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_diff_exp <- max(c(part_diff_exp$label_y, part_diff_exp$ymax), na.rm = TRUE) + 0.15
y_bot_part_diff_exp <- min(part_diff_exp$ymin, na.rm = TRUE) - 0.15
y_abs_part_diff_exp <- max(abs(c(y_bot_part_diff_exp, y_top_part_diff_exp, -1, 1)), na.rm = TRUE)

p_part_diff_exp <- ggplot2::ggplot(
  part_diff_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ owner_group, nrow = 1) +
  ggplot2::labs(
    title = "Veränderung der Teilnahmebereitschaft nach Experimentalbedingung",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen)",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Δ Teilnahmeintention (POST − PRE)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_part_diff_exp, y_abs_part_diff_exp), clip = "off")

p_part_diff_exp_branded <- brand_plot_surf(p_part_diff_exp)

save_plot(
  plot  = p_part_diff_exp_branded,
  block = 3,
  sub   = 6,
  slug  = "participation_difference_experiment_owner"
)

p_part_diff_exp_branded

```

#### Nach Adoptionsstatus und -intention

```{r}
#| label: plot-03-12-part-diff-devicegroups-experiment
#| warning: false
#| message: false

part_diff_devicegroups_exp <- daten_analysis |>
  dplyr::filter(device_group != "Gesamtstichprobe") |>
  dplyr::mutate(
    device_group = factor(
      device_group,
      levels = c(
        "Gerätebesitzer",
        "Kurzfristige Adopter",
        "Langfristig Interessierte",
        "Nicht-Adopter"
      )
    ),
    rand_freq = force_rand_freq_order(rand_freq)
  ) |>
  dplyr::group_by(device_group, rand_freq) |>
  dplyr::summarise(mean_ci_n(part_diff), .groups = "drop") |>
  dplyr::mutate(label_y = ymax + 0.12)

y_top_part_diff_devicegroups_exp <- max(c(part_diff_devicegroups_exp$label_y, part_diff_devicegroups_exp$ymax), na.rm = TRUE) + 0.15
y_bot_part_diff_devicegroups_exp <- min(part_diff_devicegroups_exp$ymin, na.rm = TRUE) - 0.15
y_abs_part_diff_devicegroups_exp <- max(abs(c(y_bot_part_diff_devicegroups_exp, y_top_part_diff_devicegroups_exp, -1, 1)), na.rm = TRUE)

p_part_diff_devicegroups_exp <- ggplot2::ggplot(
  part_diff_devicegroups_exp,
  ggplot2::aes(x = rand_freq, y = mean)
) +
  ggplot2::geom_hline(yintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_point(colour = SURF_PURPLE, size = 2.8) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ymin, ymax = ymax),
    width = 0.2,
    colour = SURF_PURPLE
  ) +
  ggplot2::geom_text(
    ggplot2::aes(y = label_y, label = round(mean, 2)),
    size = 2.9,
    vjust = 0
  ) +
  ggplot2::facet_wrap(~ device_group, nrow = 2) +
  ggplot2::labs(
    title = "Veränderung der Teilnahmebereitschaft nach Experimentalbedingung",
    subtitle = "POST − PRE (Mittelwerte mit 95%-Konfidenzintervallen) – Geräte-Untergruppen",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Δ Teilnahmeintention (POST − PRE)"
  ) +
  theme_surf(base_size = 11) +
  ggplot2::coord_cartesian(ylim = c(-y_abs_part_diff_devicegroups_exp, y_abs_part_diff_devicegroups_exp), clip = "off")

p_part_diff_devicegroups_exp_branded <- brand_plot_surf(p_part_diff_devicegroups_exp)

save_plot(
  plot  = p_part_diff_devicegroups_exp_branded,
  block = 3,
  sub   = 12,
  slug  = "participation_diff_devicegroups_experiment"
)

p_part_diff_devicegroups_exp_branded

```

## Steuerungsbereitschaft

```{r}
#| label: b04-prepare-control
#| warning: false
#| message: false

# Steuerungsvariablen
control_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^control_")]

# Lesbare Gerätelabels (bitte ggf. exakt an euren Fragebogen anpassen)
control_labels <- c(
  control_wallbox = "Wallbox",
  control_heatpump = "Wärmepumpe",
  control_battery = "Batteriespeicher",
  control_pv = "Photovoltaikanlage",
  control_ems = "Energiemanagementsystem"
)

# Long-Format
control_long <- daten_analysis |>
  dplyr::select(all_of(control_vars), owner_group, rand_freq) |>
  tidyr::pivot_longer(
    cols = all_of(control_vars),
    names_to = "device",
    values_to = "control_raw"
  ) |>
  dplyr::mutate(
    device_label = dplyr::recode(device, !!!control_labels),
    control_yes = suppressWarnings(as.integer(as.character(control_raw))) == 1
  )

```

```{r}
#| label: b04-prepare-control2
#| warning: false
#| message: false

# Steuerungsvariablen
control_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^control_")]

# Lesbare Gerätelabels (bitte ggf. exakt an euren Fragebogen anpassen)
control_labels <- c(
  control_wallbox = "Wallbox",
  control_heatpump = "Wärmepumpe",
  control_battery = "Batteriespeicher",
  control_pv = "Photovoltaikanlage",
  control_ems = "Energiemanagementsystem"
)

# Long-Format
control_long <- daten_analysis |>
  dplyr::select(all_of(control_vars), owner_group, rand_freq) |>
  tidyr::pivot_longer(
    cols = all_of(control_vars),
    names_to = "device",
    values_to = "control_raw"
  ) |>
  dplyr::mutate(
    device_label = dplyr::recode(device, !!!control_labels),
    control_yes = suppressWarnings(as.integer(as.character(control_raw))) == 1
  )

```

```{r}

#| label: b04-control-among-owners
#| warning: false
#| message: false

# ------------------------------------------------------------
# Steuerungsbereitschaft je Gerät – nur unter Gerätebesitzern
# Definition: Anteil "Ja" in control_* innerhalb owner_group == "Gerätebesitzer"
# Output:
#  - Tabelle (Prozent)
#  - Plot (Prozent), Export: outputs/plots/04_03_control_among_owners.png
# ------------------------------------------------------------

# Falls control_long noch nicht existiert (robust)
if (!exists("control_long")) {

  control_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^control_")]

  control_labels <- c(
    control_wallbox = "Wallbox",
    control_heatpump = "Wärmepumpe",
    control_battery = "Batteriespeicher",
    control_pv = "Photovoltaikanlage",
    control_ems = "Energiemanagementsystem"
  )

  control_long <- daten_analysis |>
    dplyr::select(dplyr::all_of(control_vars), owner_group, rand_freq) |>
    tidyr::pivot_longer(
      cols = dplyr::all_of(control_vars),
      names_to = "device",
      values_to = "control_raw"
    ) |>
    dplyr::mutate(
      device_label = dplyr::recode(device, !!!control_labels),
      control_yes = suppressWarnings(as.integer(as.character(control_raw))) == 1
    )
}

# 1) Nur Gerätebesitzer
control_owners <- control_long |>
  dplyr::filter(owner_group == "Gerätebesitzer")

# 2) Zustimmung je Gerät (Prozent)
control_owners_summary <- control_owners |>
  dplyr::group_by(device_label) |>
  dplyr::summarise(
    Zustimmung = mean(control_yes, na.rm = TRUE),
    n = sum(!is.na(control_yes)),
    .groups = "drop"
  ) |>
  dplyr::mutate(
    Zustimmung_pct = round(Zustimmung * 100, 1)
  ) |>
  dplyr::arrange(dplyr::desc(Zustimmung))

# Tabelle
knitr::kable(
  control_owners_summary |>
    dplyr::select(device_label, n, Zustimmung_pct),
  col.names = c("Gerät", "n (gültig)", "Zustimmung (%)"),
  align = c("l", "r", "r"),
  caption = "Grundsätzliche Bereitschaft zur automatischen Steuerung (nur unter Gerätebesitzern)."
)

# 3) Plot (Prozent)
p_control_owners <- ggplot2::ggplot(
  control_owners_summary,
  ggplot2::aes(x = Zustimmung, y = reorder(device_label, Zustimmung))
) +
  ggplot2::geom_col(fill = SURF_PURPLE, width = 0.7) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::labs(
    title = "Steuerungsbereitschaft unter Gerätebesitzern",
    subtitle = "Anteil zustimmender Haushalte (nur Haushalte mit vorhandenem Gerät)",
    x = "Zustimmung zur Steuerung",
    y = NULL
  ) +
  theme_surf(base_size = 12)

p_control_owners_branded <- brand_plot_surf(p_control_owners)

# Export
save_plot(
  plot  = p_control_owners_branded,
  block = 4,
  sub   = 3,
  slug  = "control_among_owners"
)

p_control_owners_branded


```

```{r}
#| label: plot-04-01-control-overview
#| warning: false
#| message: false

control_overview <- control_long |>
  dplyr::group_by(device_label, owner_group) |>
  dplyr::summarise(
    Anteil = mean(control_yes, na.rm = TRUE),
    .groups = "drop"
  )

p_control_overview <- ggplot2::ggplot(
  control_overview,
  ggplot2::aes(
    y = device_label,
    x = Anteil,
    fill = owner_group
  )
) +
  ggplot2::geom_col(
    position = "dodge",
    width = 0.7,
    colour = "white",
    linewidth = 0.2
  ) +
  ggplot2::scale_x_continuous(
    labels = scales::percent_format(accuracy = 1)
  ) +
  ggplot2::scale_fill_manual(
    values = c(
      "Gerätebesitzer" = SURF_PURPLE,
      "Nicht-Besitzer" = SURF_PINK
    )
  ) +
  ggplot2::labs(
    title = "Grundsätzliche Bereitschaft zur automatischen Gerätesteuerung",
    subtitle = "Anteil zustimmender Haushalte nach Gerätetyp und Gerätebesitz",
    x = "Anteil der Befragten",
    y = NULL,
    fill = NULL
  ) +
  theme_surf(base_size = 12) +
  surf_legend_bottom(nrow = 1, text_size = 9)

p_control_overview_branded <- brand_plot_surf(p_control_overview)

save_plot(
  plot = p_control_overview_branded,
  block = 4,
  sub = 1,
  slug = "control_overview_owner"
)

p_control_overview_branded

```

```{r}
#| label: plot-04-02-control-experiment
#| warning: false
#| message: false

control_exp <- control_long |>
  dplyr::group_by(device_label, owner_group, rand_freq) |>
  dplyr::summarise(
    Anteil = mean(control_yes, na.rm = TRUE),
    .groups = "drop"
  )

p_control_exp <- ggplot2::ggplot(
  control_exp,
  ggplot2::aes(
    x = rand_freq,
    y = Anteil,
    colour = owner_group,
    group = owner_group
  )
) +
  ggplot2::geom_point(size = 2.5) +
  ggplot2::geom_line(linewidth = 0.6) +
  ggplot2::facet_wrap(~ device_label) +
  ggplot2::scale_y_continuous(
    labels = scales::percent_format(accuracy = 1)
  ) +
  ggplot2::scale_colour_manual(
    values = c(
      "Gerätebesitzer" = SURF_PURPLE,
      "Nicht-Besitzer" = SURF_PINK
    )
  ) +
  ggplot2::labs(
    title = "Steuerungsbereitschaft nach Experimentalbedingung",
    subtitle = "Anteil zustimmender Haushalte nach Gerät, Besitzstatus und Steuerungshäufigkeit",
    x = "Experimentalbedingung (Häufigkeit der Steuerung)",
    y = "Anteil Zustimmung",
    colour = NULL
  ) +
  theme_surf(base_size = 11) +
  surf_legend_bottom(nrow = 1, text_size = 9)

p_control_exp_branded <- brand_plot_surf(p_control_exp)

save_plot(
  plot = p_control_exp_branded,
  block = 4,
  sub = 2,
  slug = "control_experiment_owner"
)

p_control_exp_branded

```

```{r}
#| label: table-04-control-summary
#| warning: false
#| message: false

control_table <- control_overview |>
  dplyr::mutate(
    Anteil = round(Anteil * 100, 1)
  )

knitr::kable(
  control_table,
  col.names = c("Gerät", "Besitzstatus", "Zustimmung (%)"),
  align = c("l", "l", "r"),
  caption = "Grundsätzliche Bereitschaft zur automatischen Gerätesteuerung nach Gerätetyp und Besitzstatus."
)

```

```{r}
#| label: b04-control-among-nonowners
#| warning: false
#| message: false

# ------------------------------------------------------------
# Steuerungsbereitschaft je Gerät – nur unter Nicht-Besitzern
# Output:
#  - Tabelle (Prozent)
#  - Plot (Prozent), Export: outputs/plots/04_04_control_among_nonowners.png
# ------------------------------------------------------------

# control_long falls nötig erzeugen (robust)
if (!exists("control_long")) {

  control_vars <- names(daten_analysis)[stringr::str_detect(names(daten_analysis), "^control_")]

  control_labels <- c(
    control_wallbox  = "Wallbox",
    control_heatpump = "Wärmepumpe",
    control_battery  = "Batteriespeicher",
    control_pv       = "Photovoltaikanlage",
    control_ems      = "Energiemanagementsystem"
  )

  control_long <- daten_analysis |>
    dplyr::select(dplyr::all_of(control_vars), owner_group, rand_freq) |>
    tidyr::pivot_longer(
      cols = dplyr::all_of(control_vars),
      names_to = "device",
      values_to = "control_raw"
    ) |>
    dplyr::mutate(
      device_label = dplyr::recode(device, !!!control_labels),
      control_yes  = suppressWarnings(as.integer(as.character(control_raw))) == 1
    )
}

control_nonowners <- control_long |>
  dplyr::filter(owner_group == "Nicht-Besitzer")

control_nonowners_summary <- control_nonowners |>
  dplyr::group_by(device_label) |>
  dplyr::summarise(
    Zustimmung = mean(control_yes, na.rm = TRUE),
    n = sum(!is.na(control_yes)),
    .groups = "drop"
  ) |>
  dplyr::mutate(
    Zustimmung_pct = round(Zustimmung * 100, 1)
  ) |>
  dplyr::arrange(dplyr::desc(Zustimmung))

# Tabelle
knitr::kable(
  control_nonowners_summary |>
    dplyr::select(device_label, n, Zustimmung_pct),
  col.names = c("Gerät", "n (gültig)", "Zustimmung (%)"),
  align = c("l", "r", "r"),
  caption = "Grundsätzliche Bereitschaft zur automatischen Steuerung (nur unter Nicht-Besitzern)."
)

# Plot
p_control_nonowners <- ggplot2::ggplot(
  control_nonowners_summary,
  ggplot2::aes(x = Zustimmung, y = reorder(device_label, Zustimmung))
) +
  ggplot2::geom_col(fill = SURF_PINK, width = 0.7) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::labs(
    title = "Steuerungsbereitschaft unter Nicht-Besitzern",
    subtitle = "Anteil zustimmender Haushalte (Haushalte ohne vorhandenes Gerät)",
    x = "Zustimmung zur Steuerung",
    y = NULL
  ) +
  theme_surf(base_size = 12)

p_control_nonowners_branded <- brand_plot_surf(p_control_nonowners)

save_plot(
  plot  = p_control_nonowners_branded,
  block = 4,
  sub   = 4,
  slug  = "control_among_nonowners"
)

p_control_nonowners_branded

```

```{r}
#| label: b04-control-owner-nonowner-diff
#| warning: false
#| message: false

# ------------------------------------------------------------
# Differenz je Gerät: Zustimmung (Besitzer) - Zustimmung (Nicht-Besitzer)
# Output:
#  - Plot, Export: outputs/plots/04_05_control_owner_minus_nonowner.png
# ------------------------------------------------------------

control_diff <- control_long |>
  dplyr::group_by(device_label, owner_group) |>
  dplyr::summarise(
    Zustimmung = mean(control_yes, na.rm = TRUE),
    .groups = "drop"
  ) |>
  tidyr::pivot_wider(
    names_from = owner_group,
    values_from = Zustimmung
  ) |>
  dplyr::mutate(
    diff = `Gerätebesitzer` - `Nicht-Besitzer`
  ) |>
  dplyr::arrange(diff)

p_control_diff <- ggplot2::ggplot(
  control_diff,
  ggplot2::aes(x = diff, y = reorder(device_label, diff))
) +
  ggplot2::geom_vline(xintercept = 0, colour = SURF_GRID, linewidth = 0.4) +
  ggplot2::geom_col(fill = SURF_MAG, width = 0.7) +
  ggplot2::scale_x_continuous(labels = scales::percent_format(accuracy = 1)) +
  ggplot2::labs(
    title = "Besitz-Effekt auf die Steuerungsbereitschaft",
    subtitle = "Differenz der Zustimmungsanteile: Gerätebesitzer minus Nicht-Besitzer",
    x = "Differenz in Prozentpunkten",
    y = NULL
  ) +
  theme_surf(base_size = 12)

p_control_diff_branded <- brand_plot_surf(p_control_diff)

save_plot(
  plot  = p_control_diff_branded,
  block = 4,
  sub   = 5,
  slug  = "control_owner_minus_nonowner"
)

p_control_diff_branded

```



# Insights: SURF Convenience Survey



